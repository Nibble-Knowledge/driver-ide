
IDE_Write.Enter:

#Subject to change if necessary
MOV N_[1] INTO CHIP_SELECT

#Enter sector count - always 1

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[A] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[1] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#execute

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS


#Enter sector number - 8 bits

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[B] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV IDE_WRITE.SecNum[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV IDE_WRITE.SecNum[1] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#execute

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS

#Enter Cylinder number - 8 bits twice
#Yes, this is in 2 - 3 - 0 - 1 order
#MSB first within 8 bits, LSB first by bytes


MOV N_[0b0100] INTO STATUS_BUS
MOV N_[C] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV IDE_WRITE.Cyl[2] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV IDE_WRITE.Cyl[3] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#execute

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS


MOV N_[0b0100] INTO STATUS_BUS
MOV N_[D] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV IDE_WRITE.SecNum[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV IDE_WRITE.SecNum[1] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#execute

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS


#Drive head - this currently can't be changed


MOV N_[0b0100] INTO STATUS_BUS
MOV N_[E] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[E] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#execute

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS


#Tell it to start writing (0x20 to reg F)


MOV N_[0b0100] INTO STATUS_BUS
MOV N_[F] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[3] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#execute

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS


MOV N_[0] INTO IDE_WRITE.LoopCount[0]
MOV N_[0] INTO IDE_WRITE.LoopCount[1]
MOV N_[0] INTO IDE_WRITE.LoopCount[2]
MOV N_[0] INTO IDE_WRITE.LoopCount[3]

MOV16 IDE_WRITE.DataPtr INTO IDE_WRITE.Ptr1[1]

IDE_WRITE.Loop:

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[8] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#This code self-modifys by inserting the data pointer
#provided into the LOD instructions below, then incrementing it
#and putting the result in the other LOD instruction

MOV N_[0b0100] INTO STATUS_BUS
IDE_WRITE.Ptr1:
LOD 0x0000
STR DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

INC16 IDE_WRITE.Ptr1[1] INTO IDE_WRITE.Ptr2[1]

MOV N_[0b0100] INTO STATUS_BUS
IDE_WRITE.Ptr2:
LOD 0x0000
STR DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

INC16 IDE_WRITE.Ptr2[1] INTO IDE_WRITE.Ptr1[1]

#execute

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0b0000] INTO STATUS_BUS

#Control flow - this loop only goes around 256 times

INC8 IDE_WRITE.LoopCount
GETCARR ACC
LOGNOT ACC
JMP IDE_WRITE.DoneLoop

LOD N_[0]
JMP IDE_WRITE.Loop

IDE_WRITE.DoneLoop:

IDE_WRITE.CheckLoop:

#Check for error codes

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[F] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#execute

MOV N_[0b1000] INTO STATUS_BUS
LOD DATA_BUS
STR IDE_WRITE.Status[0]
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b1000] INTO STATUS_BUS
LOD DATA_BUS
STR IDE_WRITE.Status[1]
MOV N_[0b0000] INTO STATUS_BUS

#Loop until MSB of .Status[1] is 0
LOD IDE_WRITE.Status[1]
ADD N_[8]
GETCARR ACC
LOGNOT ACC
JMP IDE_WRITE.CheckLoop

#Check the status register one last time,
#leaving the code for the higher-level coder.

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[F] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

MOV N_[0b0100] INTO STATUS_BUS
MOV N_[0] INTO DATA_BUS
MOV N_[0b0000] INTO STATUS_BUS

#execute

MOV N_[0b1000] INTO STATUS_BUS
LOD DATA_BUS
STR IDE_WRITE.Status[0]
MOV N_[0b0000] INTO STATUS_BUS
MOV N_[0b1000] INTO STATUS_BUS
LOD DATA_BUS
STR IDE_WRITE.Status[1]
MOV N_[0b0000] INTO STATUS_BUS


#Exit - this needs the return address to be supplied
LOD N_[0]
IDE_WRITE.Exit:
JMP 0x0000


IDE_WRITE.SecNum: 	.data 2
IDE_WRITE.Cyl:		.data 4
IDE_WRITE.DataPtr:	.data 4
IDE_WRITE.LoopCount: 	.data 2 0x0
IDE_WRITE.Status:	.data 2
